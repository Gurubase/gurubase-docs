---
title: 'Text-to-Speech Stream V2'
api: 'POST /{guru_type}/text-to-speech-v2/stream/'
description: 'Convert text to speech using ElevenLabs TTS with OpenAI fallback and stream audio response'
---

Convert text to speech using ElevenLabs TTS API with OpenAI fallback and stream the audio response. Code blocks and inline code are automatically processed for better speech generation.

<Note>
This feature requires special activation. Please contact our support team to enable ElevenLabs TTS for your account.
</Note>

<RequestExample>
```bash cURL
curl --request POST \
  --url https://api.gurubase.io/api/v1/{guru_slug}/text-to-speech-v2/stream/ \  
  --header 'x-api-key: YOUR_API_KEY' \
  --header 'Content-Type: application/json' \
  --data '{
    "text": "Hello, this is a test message with some code: `console.log(\"hello\")` and a code block:\n```python\ndef hello():\n    print(\"hello\")\n```"
  }'
```

</RequestExample>

## Path Parameters

<ParamField path="guru_type" type="string" required>
  The guru type identifier for the text-to-speech request
</ParamField>

## Headers

<ParamField header="x-api-key" type="string" required>
  Your API key for authentication. You can obtain your API key from the [Gurubase.io](https://gurubase.io/api-keys) dashboard.
</ParamField>

### Body Parameters

<ParamField body="text" type="string" required>
  The text to convert to speech
</ParamField>

### Response

The response is a streaming audio file in MP3 format.

<ResponseField name="audio_stream" type="audio/mpeg">
  Streaming audio response in MP3 format
</ResponseField>

<ResponseExample>
```json 400
{
  "msg": "No text provided"
}
```

```json 401
{
  "error": "Invalid API key"
}
```

```json 403
{
  "msg": "Text-to-speech is not enabled for this guru type"
}
```

```json 429
{
  "error": "Rate limit exceeded"
}
```

```json 500
{
  "msg": "Error generating speech stream"
}
```
</ResponseExample>

## TTS Provider Fallback

This endpoint uses a sophisticated fallback system:

1. **Primary**: ElevenLabs TTS API (if configured and available)
2. **Fallback**: OpenAI TTS API (if ElevenLabs fails or is not configured)

The system automatically handles provider failures and seamlessly switches between providers to ensure reliable audio generation.

## Streaming Response

The endpoint returns a streaming audio response with the following headers:
- `Content-Type: audio/mpeg`
- `Cache-Control: no-cache`
- `X-Accel-Buffering: no` (disables nginx buffering for real-time streaming)

## Code Examples

### Streaming the TTS

This example demonstrates how to send a request and start streaming without waiting for the whole response to finish. It is a full HTML + JS example, so you can paste it into an HTML and JS file, change your constants, and immediately test it out.

#### HTML File:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>TTS Stream (Single Button)</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
        max-width: 720px;
        margin: 40px auto;
        padding: 0 16px;
      }
      textarea {
        width: 100%;
        height: 100px;
      }
      button {
        padding: 10px 14px;
        min-width: 120px;
      }
    </style>
  </head>
  <body>
    <h2>TTS Stream (Single Button)</h2>

    <label for="text">Text:</label>
    <textarea id="text">
Hello, this is an example for streaming ElevenLabs TTS using Gurubase API.</textarea
    >

    <div style="margin: 12px 0">
      <button id="toggleBtn">Start</button>
    </div>

    <audio id="tts" controls></audio>

    <script src="the/path/to/below/js/file"></script>
  </body>
</html>
```

#### JS File:
```javascript
// ====== Constants ======
const BASE_URL = "http://localhost:8008/api/v1";
const GURU_SLUG = "gurubase"; // adjust if needed
const API_KEY = "gb-td4rz6kq4jms2z02fti3pa0gyu63sf";

const API_URL = `${BASE_URL}/${GURU_SLUG}/text-to-speech-v2/stream/`;

// ====== DOM ======
const audioEl = document.getElementById("tts");
const toggleBtn = document.getElementById("toggleBtn");
const textEl = document.getElementById("text");

// ====== State ======
let abortCtrl = null;
let mediaSource = null;
let sourceBuffer = null;
let reader = null; // ReadableStreamDefaultReader
let queue = [];
let streaming = false; // network stream active
let ended = false; // server finished
let startedOnce = false; // did we start a stream in this session?

// ====== Helpers ======
function setButton(label) {
  toggleBtn.textContent = label;
}

function resetAudio() {
  try {
    audioEl.pause();
  } catch {}
  if (abortCtrl) {
    try {
      abortCtrl.abort();
    } catch {}
  }
  if (mediaSource && mediaSource.readyState === "open") {
    try {
      mediaSource.endOfStream();
    } catch {}
  }
  audioEl.removeAttribute("src");
  audioEl.load();

  abortCtrl = null;
  mediaSource = null;
  sourceBuffer = null;
  reader = null;
  queue = [];
  streaming = false;
  ended = false;
  startedOnce = false;
  setButton("Start");
}

function ensureMediaSource() {
  return new Promise((resolve, reject) => {
    mediaSource = new MediaSource();
    audioEl.src = URL.createObjectURL(mediaSource);
    mediaSource.addEventListener(
      "sourceopen",
      () => {
        try {
          sourceBuffer = mediaSource.addSourceBuffer("audio/mpeg");
          sourceBuffer.mode = "sequence";
          sourceBuffer.addEventListener("updateend", onUpdateEnd);
          resolve();
        } catch (e) {
          reject(e);
        }
      },
      { once: true }
    );
  });
}

function onUpdateEnd() {
  if (queue.length && !sourceBuffer.updating) {
    sourceBuffer.appendBuffer(queue.shift());
  } else if (
    ended &&
    !sourceBuffer.updating &&
    mediaSource?.readyState === "open"
  ) {
    try {
      mediaSource.endOfStream();
    } catch {}
  }
}

async function startNetworkStream(text) {
  streaming = true;
  ended = false;
  abortCtrl = new AbortController();

  const resp = await fetch(API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-API-Key": API_KEY
    },
    body: JSON.stringify({ text: text || " " }),
    signal: abortCtrl.signal
  });

  if (!resp.ok || !resp.body) {
    streaming = false;
    throw new Error("TTS API error: " + resp.status);
  }

  reader = resp.body.getReader();
  // run without awaiting (keep UI responsive)
  pump().catch((err) => console.warn("pump error:", err));
}

async function pump() {
  try {
    while (true) {
      const { done, value } = await reader.read();

      if (done) break;
      if (value && value.byteLength) {
        if (!sourceBuffer || sourceBuffer.updating || queue.length) {
          queue.push(value.buffer);
        } else {
          try {
            sourceBuffer.appendBuffer(value.buffer);
          } catch {
            queue.push(value.buffer);
          }
        }
      }
    }
  } catch (e) {
    if (e.name !== "AbortError") console.warn("Stream reader error:", e);
  } finally {
    streaming = false;
    ended = true;
    if (
      sourceBuffer &&
      !sourceBuffer.updating &&
      mediaSource?.readyState === "open"
    ) {
      try {
        mediaSource.endOfStream();
      } catch {}
    }
  }
}

async function startStreamSession() {
  // clean any previous session
  resetAudio();

  // create MSE & SourceBuffer
  await ensureMediaSource();

  // start network stream and playback
  await startNetworkStream(textEl.value);
  startedOnce = true;

  // user-gesture started, so play should succeed
  await audioEl.play().catch(() => {});
}

async function toggleHandler() {
  // If no stream yet or previous one ended â†’ start a new session
  if (!startedOnce || ended) {
    try {
      await startStreamSession();
    } catch (e) {
      console.error(e);
    }

    return;
  }

  // If stream already started: toggle play/pause
  if (audioEl.paused) {
    await audioEl.play().catch(() => {});
    setButton("Pause");
  } else {
    audioEl.pause();
    setButton("Play");
  }
}

// ====== Wire up ======
toggleBtn.addEventListener("click", toggleHandler);
// If you ever need a full reset programmatically, call resetAudio();
```